(* 
                         CS 51 Final Project
                         MiniML -- Evaluation
                             Spring 2017
*)

(* This module implements a small untyped ML-like language under
   various operational semantics.
 *)
    
open Expr ;;
  
(* Exception for evaluator runtime, generated by a runtime error *)
exception EvalError of string ;;
(* Exception for evaluator runtime, generated by an explicit "raise" construct *)
exception EvalException ;;


(* Environments and values *)

module type Env_type = sig
    type env
    type value =
      | Val of expr
      | Closure of (expr * env)
    val create : unit -> env
    val close : expr -> env -> value
    val lookup : env -> varid -> value
    val extend : env -> varid -> value ref -> env
    val env_to_string : env -> string
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : Env_type =
  struct
    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    (* Creates an empty environment *)
    let create () : env = [] ;;

    (* Creates a closure from an expression and the environment it's
       defined in *)
    let close (exp : expr) (env : env) : value =
      failwith "close not implemented" ;;

    (* Looks up the value of a variable in the environment *)
    let lookup (env : env) (varname : varid) : value =
      failwith "lookup not implemented" ;;

    (* Returns a new environment just like env except that it maps the
       variable varid to loc *)
    let extend (env : env) (varname : varid) (loc : value ref) : env =
      failwith "extend not implemented" ;;

    (* Returns a printable string representation of a value; the flag
       printenvp determines whether to include the environment in the
       string representation when called on a closure *)
    let value_to_string ?(printenvp : bool = true) (v : value) : string =
      failwith "value_to_string not implemented" ;;

   (* Returns a printable string representation of an environment *)
   let env_to_string (env : env) : string =
     failwith "env_to_string not implemented" ;;

  end
;;
  
(* The evaluation function: Returns the result of type `value` of
   evaluating the expression `exp` in the environment `env`. In this
   initial implementation, we just convert the expression unchanged to
   a value and return it. *)


(** The external evaluator, which can be either the identity function,
    the substitution model version or the dynamic or lexical
    environment model version. *)

let eval_t exp _env = exp ;;
(*everytime we run into a let add that var to the env and then replace
 * free variables  as we check if they are free*)
let rec eval_s exp env =
  (*helper function to evaluate binops *)
  let eval_binop (b : binop) (e1 : expr) (e2 : expr) : expr =
    match b, e1, e2 with
    | Plus, Num n1, Num n2 -> Num (n1 + n2)
    | Minus, Num n1, Num n2 -> Num (n1 - n2)
    | Times, Num n1, Num n2 -> Num (n1 * n2)
    | Equals, e1, e2 -> Bool (e1 = e2)
    | LessThan, e1, e2 -> Bool (e1 < e2)
    | _ -> raise (EvalError "Binop used on incorrect types") in
  (*helper function to recursively evaluate nested apps, e is the expr
   * which is applied to possibly nested functions *)
  let rec eval_app (a : expr) (e : expr) : expr =
    match a with
    | Fun(id, f) -> eval_s (subst id e f) env
    | Letrec(id, recfun, e2) ->
        let (fid, body) =
          match recfun with
          | Fun(fid, body) -> fid,body
          | _ -> raise (EvalError "cannot use letrec with a non function") in
        let newvar = new_varname () in
        let newrecfun = Fun(newvar, subst fid (Var(newvar)) body) in
        let newe1 = subst id (Letrec(id,newrecfun,Var(id))) recfun in
        let (new_fid, new_body) = 
          match newe1 with
          | Fun(new_fid, new_body) -> new_fid, new_body
          | _ -> raise (EvalError "cannot use letrec with a non function") in
        eval_s (subst id (subst new_fid e new_body) e2)env
    | App(App(e1, e2), Fun(id, f)) -> 
        eval_app(App(e1, e2)) (eval_s (subst id e f) env)
    | App(App(e1, e2), e) -> eval_app (App(e1, e2)) e
    | App(Fun(id1, f1), Fun(id2, f2)) -> 
        eval_s (subst id1 (eval_s (subst id2 e f2)env) f1) env
    | _ -> raise (EvalError "this is not a function, it cannot be applied") in
  match exp with 
  | Var id -> Var id
  | Bool b -> Bool b
  (*currently do not need to worry about what the unop is as we only have 1 *)
  | Unop(_, e) -> 
      (match (eval_s e env) with
      | Num n -> Num (~- n)
      | _ -> raise (EvalError "attempted to negate a non-integer") )
  | Binop(b, e1, e2) -> eval_binop b (eval_s e1 env) (eval_s e2 env) 
  | Conditional(e1, e2, e3) -> 
      (match eval_s e1 env with 
      | Bool true -> eval_s e2 env
      | Bool false -> eval_s e3 env
      | _ -> raise (EvalError ": is not of type bool ")) 
  (*if we find a unapplied function we should just reuturn it as utop does*)
  | Fun(id, e) -> Fun(id, e)
  | Let(id, e1, e2)-> 
      (*first case covers aliasing, i.e let x = y in let y = ... *)
      (match e2 with 
      | Let(id2, def, body) -> 
          if id = id2 then eval_s (Let(id, def, body)) env
          else eval_s (Let(id2, subst id e1 def, subst id e1 body)) env
      | _ -> eval_s (subst id e1 e2) env)
  | Letrec(id, recfun, e2) -> 
      let (recfun_id, recfun_body) = 
        (match recfun with
        | Fun(recfun_id, recfun_body) -> recfun_id, recfun_body
        | _ -> raise (EvalError "cannot use letrec with a non function")) in
      let newvar = new_varname () in
      let newrecfun = Fun(newvar, subst recfun_id (Var(newvar)) recfun_body) in
      let newe1 = subst id (Letrec(id,newrecfun,Var(id))) recfun in
      (match e2 with 
      | Letrec(id2, def, body) ->
          if id = id2 then eval_s (Letrec(id, def, body)) env
          else eval_s (Letrec(id2, subst id recfun def, 
                       subst id recfun body)) env
      | _ -> eval_s (subst id newe1 e2) env)
  | Raise -> raise (EvalError "exception raised")
  | Unassigned -> raise EvalException
  | App (f, e1) -> eval_app f (eval_s e1 env)
  | Num n -> Num n
   ;; 
let eval_d _ = failwith "eval_d not implemented" ;;
let eval_l _ = failwith "eval_l not implemented" ;;

let evaluate = eval_t ;;
