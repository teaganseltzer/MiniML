(* 
                         CS 51 Final Project
                         MiniML -- Evaluation
                             Spring 2017
*)

(* This module implements a small untyped ML-like language under
   various operational semantics.
 *)
    
open Expr ;;
  
(* Exception for evaluator runtime, generated by a runtime error *)
exception EvalError of string ;;
(* Exception for evaluator runtime, generated by an explicit "raise" construct *)
exception EvalException ;;


(* Environments and values *)

module type Env_type = sig
    type env
    type value =
      | Val of expr
      | Closure of (expr * env)
    val create : unit -> env
    val close : expr -> env -> value
    val lookup : env -> varid -> value
    val extend : env -> varid -> value ref -> env
    val env_to_string : env -> string
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : Env_type =
  struct
    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    (* Creates an empty environment *)
    let create () : env = [] ;;

    (* Creates a closure from an expression and the environment it's
       defined in *)
    let close (exp : expr) (env : env) : value =
      Closure(exp, env)

    (* Looks up the value of a variable in the environment *)
    let lookup (env : env) (varname : varid) : value =
      try  
        let (_, valref) = List.find (fun (id, _) -> id = varname) env in
        !valref
      with
      Not_found -> raise (EvalError ("unbound variable " ^ varname)) 
    (* Returns a new environment just like env except that it maps the
       variable varid to loc *)
    let extend (env : env) (varname : varid) (loc : value ref) : env =
      try 
        let(_) = lookup env varname in
        List.map (fun (id, valref) -> if id = varname then id, loc else id, valref)
        env
      with
        EvalError _ -> (varname, loc) :: env  

    (* Returns a printable string representation of a value; the flag
       printenvp determines whether to include the environment in the
       string representation when called on a closure *)
    let rec value_to_string ?(printenvp : bool = true) (v : value) : string =
      match v with 
      | Closure(exp, env) -> 
          if printenvp then
            "value: " ^ (exp_to_string exp) ^ " \n env: " ^ (List.fold_right 
            (fun (id, valref) c -> id ^ (value_to_string !valref) ^ c ) env "")
          else exp_to_string exp 
      | Val e -> exp_to_string e
   
   (* Returns a printable string representation of an environment
    * Note on design, this reuses code in value_to_string. I would use
    * a helper function to reuse code but value_to_string would not be
    * in the scope of a helper function defined before value_to_string. *)
   let env_to_string (env : env) : string =
     (List.fold_right (fun (id, valref) c -> "id: " ^ id ^ "val:" ^
                      (value_to_string !valref ^ "\n")
      ^ c ) env "")

  end
;;
  
(* The evaluation function: Returns the result of type `value` of
   evaluating the expression `exp` in the environment `env`. In this
   initial implementation, we just convert the expression unchanged to
   a value and return it. *)


(** The external evaluator, which can be either the identity function,
    the substitution model version or the dynamic or lexical
    environment model version. *)

let eval_t exp _env = exp ;;

(*helper function to evaluate binops *)
  let eval_binop (b : binop) (e1 : expr) (e2 : expr) : expr =
    match b, e1, e2 with
    | Plus, Num n1, Num n2 -> Num (n1 + n2)
    | Minus, Num n1, Num n2 -> Num (n1 - n2)
    | Times, Num n1, Num n2 -> Num (n1 * n2)
    | Equals, e1, e2 -> Bool (e1 = e2)
    | LessThan, e1, e2 -> Bool (e1 < e2)
    | _ -> 
         print_string (exp_to_string e1 ^ "   " ^ exp_to_string e2);
        raise (EvalError "Binop used on incorrect types");;

let rec eval_s exp env =
  match exp with 
  | Var id -> raise (EvalError "unbound variable")
  | Bool b -> Bool b
  (*currently do not need to worry about what the unop is as we only have 1 *)
  | Unop(_, e) -> 
      (match (eval_s e env) with
      | Num n -> Num (~- n)
      | _ -> raise (EvalError "attempted to negate a non-integer") )
  | Binop(b, e1, e2) -> eval_binop b (eval_s e1 env) (eval_s e2 env) 
  | Conditional(e1, e2, e3) -> 
      (match eval_s e1 env with 
      | Bool true -> eval_s e2 env
      | Bool false -> eval_s e3 env
      | _ -> raise (EvalError ": is not of type bool ")) 
  (*if we find a unapplied function we should just reuturn it as utop does*)
  | Fun(id, e) -> Fun(id, e)
  | Let(id, e1, e2)-> 
      (*first case covers aliasing, i.e let x = y in let y = ... *)
      (match e2 with 
      | Let(id2, def, body) -> 
          if id = id2 then eval_s (Let(id, def, body)) env
          else eval_s (Let(id2, subst id e1 def, subst id e1 body)) env
      | _ -> eval_s (subst id e1 e2) env)
  | Letrec(id, recfun, e2) -> 
      let (recfun_id, recfun_body) = 
        (match recfun with
        | Fun(recfun_id, recfun_body) -> recfun_id, recfun_body
        | _ -> raise (EvalError "cannot use letrec with a non function")) in
      let newvar = new_varname () in
      let newrecfun = Fun(newvar, subst recfun_id (Var(newvar)) recfun_body) in
      let newe1 = subst id (Letrec(id,newrecfun,Var(id))) recfun in
      (match e2 with 
      | Letrec(id2, def, body) ->
          if id = id2 then eval_s (Letrec(id, def, body)) env
          else eval_s (Letrec(id2, subst id recfun def, 
                       subst id recfun body)) env
      | _ -> eval_s (subst id newe1 e2) env)
  | Raise -> raise EvalException
  | Unassigned -> raise (EvalError "Unassigned variable")
  | App (f, e1) ->
      (match eval_s f env, eval_s e1 env with
      | (Fun(id, body), e ) -> 
          eval_s (subst id (eval_s e env) body ) env
      | _ -> raise (EvalError "this is not a function it cannot be applied"))
  | Num n -> Num n ;; 

(*helper function to find find value of var in env *)
let replace id env : expr = 
  match Env.lookup env id with
  | Env.Val (expr) -> expr
  | Env.Closure (expr, _) -> expr ;;

let rec eval_d (exp : expr) (env : Env.env) : expr =
  match exp with 
  | Var id -> eval_d (replace id env) env
  | Bool b -> Bool b
  | Unop(_, e) -> 
      (match (eval_d e env) with
      | Num n -> Num (~- n)
      | _ -> raise (EvalError "attempted to negate a non-integer"))
  | Binop(b, e1, e2) -> eval_binop b (eval_d e1 env) (eval_d e2 env) 
  | Conditional(e1, e2, e3) ->
      (match eval_d e1 env with 
      | Bool true -> eval_d e2 env
      | Bool false -> eval_d e3 env
      | _ -> raise (EvalError (exp_to_string e1 ^": is not of type bool "))) 
  | Fun(id, e) -> Fun(id, e)
  | Let(id, e1, e2)-> eval_d e2 (Env.extend env id (ref (Env.Val e1))) 
  | Letrec(id, recfun, e2) ->
      let eval_recfun = (eval_d recfun (Env.extend env id (ref 
                        (Env.Val Unassigned)))) in
      eval_d e2 (Env.extend env id (ref (Env.Val eval_recfun)))
  | Raise -> raise EvalException
  | Unassigned -> raise (EvalError "Unassigned variable")
  | App (f, e1) ->
      (match eval_d f env, eval_d e1 env with
       | (Fun(id, body), e ) ->
            eval_d body (Env.extend env id (ref (Env.Val e)))  
       | _ -> raise (EvalError "this is not a function it cannot be applied"))

  (*    eval_app f (eval_d e1 env) env *) 
  | Num n -> Num n
   ;;
(* in eval_l we want to work with values instead of exprs, so we need to do
  * most of our evaluation inside a helper function and then match the 
  * result to return an expr for minimml.ml to display*)
let cur_def id env : bool =
  try
    let _ = replace id env in
    true 
  with
    EvalError _ -> false ;;
let eval_l (exp : expr) (env : Env.env) : expr = 
  let rec heval_l (exp_val : Env.value) : Env.value = 
    (*print_string ("start val  "^Env.value_to_string exp_val ^ "\n"); *)
    let (exp, env)=
      match exp_val with 
      | Env.Val e -> (e, Env.create()) 
      | Env.Closure (ex, en) -> (ex, en) in  
    print_string ("start exp" ^ exp_to_string exp ^"\n");
    match exp with 
    | Var id -> heval_l (Env.close(replace id env) env)
    | Bool b -> Env.close (Bool b) env
    | Unop(_, e) -> 
        (match (heval_l (Env.close e env)) with
        | Env.Closure(Num n, env2) -> Env.close (Num (~- n)) env2
        | _ -> raise (EvalError "attempted to negate a non-integer") )
    | Binop(b, e1, e2) -> 
        (match (heval_l (Env.close e1 env)), (heval_l (Env.close e2 env)) with
        | Env.Closure(e1, _), Env.Closure(e2, _) ->
             Env.close (eval_binop b e1 e2) env
        | _ -> raise (EvalError "eval_l passed Val instead of Closure"))
    | Conditional(e1, e2, e3) ->
        (match heval_l (Env.close e1 env) with 
        | Env.Closure(Bool true, env1) -> heval_l (Env.close e2 env1)
        | Env.Closure(Bool false, env1) -> heval_l (Env.close e3 env1)
        | _ -> raise (EvalError (exp_to_string e1 ^": is not of type bool ")))
    | Fun(id, e) -> 
        print_string (Env.value_to_string (Env.close (Fun(id,e)) env ));
        let env1 = 
        match (Env.lookup env id) with
        |Env.Closure (_, en) -> en
        |Env.Val _ -> Env.create ()  in
        Env.close (Fun(id, e)) env1
    | Let(id, e1, e2)->
       (* if cur_def id env then heval_l (Env.close e2 env)
        else *)  heval_l (Env.close e2 (Env.extend env id (ref (Env.close e1 env))) )  
    (*    let env1 =  (Env.extend env id (ref (Env.Val e1))) in  
        print_string ("env1 " ^Env.env_to_string env1 ^ "\n");
        (match e2 with    
         | Let(id2, exp1, exp2) -> heval_l (Env.close exp2 (Env.extend env id2 (ref (heval_l (Env.close exp1 env1))))) 
         | _ ->  heval_l (Env.close e2 env1)) 
  *)  | Letrec(id, recfun, e2) ->
        let eval_recfun = (heval_l (Env.close recfun (Env.extend env id (ref 
                          (Env.Val Unassigned))))) in
        heval_l (Env.close e2 (Env.extend env id (ref eval_recfun)))
    | Raise -> raise EvalException
    | Unassigned -> raise (EvalError "Unassigned variable")
    | App (f, e1) ->
      
      print_string ((Env.env_to_string env) ^ "\n");
     (match heval_l (Env.close f env), heval_l (Env.close e1 env) with
      | Env.Closure(Fun(id, body), env1), Env.Closure(e, _) -> 
         print_string ("env: "^(Env.env_to_string (Env.extend env id (ref (Env.Val e)))) ^ "\n");
          heval_l (Env.close body (Env.extend env1 id (ref (Env.Val e))))
      | _ -> raise (EvalError "this is not a function it cannot be applied"))
    | Num n -> (Env.close(Num n) env) in
  match heval_l (Env.close exp env) with
  | Env.Val exp -> exp
  | Env.Closure (exp, _) -> exp;;
   
let evaluate = eval_l ;;
